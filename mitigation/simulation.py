# quantum_mitigation/simulation.py

from qiskit import transpile
from qiskit.quantum_info import Pauli, Statevector
from qiskit_aer import AerSimulator
from qiskit.providers.fake_provider import GenericBackendV2
from math import pi
import numpy as np

def expectation_value_from_counts(counts, nshots):
    """
        calculate the expectation value based on the parity of bitstrings in counts.

        parameters:
        - counts (dict): A dictionary where keys are bitstrings (e.g., '0110') and values are their respective counts.
        - nshots (int): The total number of shots (measurements).

        returns:
        - float: The expectation value.
    """
    exp_val = 0
    for bitstring, count in counts.items():
        n = int(bitstring, 2)
        parity = bin(n).count('1') % 2
        exp_val += -count if parity else count
    return exp_val / nshots

def simulate_noisy_expectation(circuits, nshots = 4096):
    """
        simulate noisy expectation value for all circuits using GenericBackendV2

        parameters:
        - circuits (list): a list of all training circuits generated prior to this step
        - nshots (int): the total number of shots (measurements).

        returns:
        - list: the noisy_exp_vals list.
    """

    # get device backend
    device_backend = GenericBackendV2(2)
    # set the 
    # its backend properties are "backend properties are generated by randomly sampling 
    # from default ranges extracted from historical IBM backend data" [IBM, 2024]
    sim = AerSimulator.from_backend(device_backend)
    noisy_exp_vals = []

    # for each circuit and its index
    for idx, circuit in enumerate(circuits): 
        # transpile the circuit using simulator from above
        tqc = transpile(circuit, sim) 
        # run the job and get the results, and counts
        job = sim.run(tqc, shots = nshots)
        result_noise = job.result()
        counts_noise = result_noise.get_counts()

        # if there are counts (this is to prevent error of "No counts for...")
        if counts_noise:
            # get the expecation values for the noisy simulation
            noisy_exp_val = expectation_value_from_counts(counts_noise, nshots) 
            # append them to the list
            noisy_exp_vals.append(noisy_exp_val)
        else:
            # print error and append none
            print(f'No counts returned for circuit {idx+1}.')
            noisy_exp_vals.append(None)  

    return noisy_exp_vals


def simulate_exact_expectation(circuit, observable = 'ZZ'):
    """
        simulate exact expectation value for the given circuit using GenericBackendV2

        parameters:
        - circuit (QuantumObject): the circuits set up by the user
        - observable (string): the pauli observable we are trying to get expectation value for

        returns:
        - float: the exact exp_val (expectation value) of the circuit.
    """

    # set up the operator
    psi = Statevector.from_instruction(circuit)
    # get the expectation value -> essentiatlly PSI@Pauli_Observable@PSI*
    exp_val = psi.expectation_value(Pauli(observable)).real
    return exp_val

